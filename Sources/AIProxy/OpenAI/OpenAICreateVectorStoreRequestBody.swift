//
//  OpenAICreateVectorStoreRequestBody.swift
//  AIProxy
//
//  Created by Lou Zell on 7/6/25.
//

import Foundation

/// https://platform.openai.com/docs/api-reference/vector-stores/create
public struct OpenAICreateVectorStoreRequestBody: Encodable {
    /// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
    /// Only applicable if `file_ids` is non-empty.
    public let chunkingStrategy: ChunkingStrategy?

    /// The expiration policy for a vector store.
    public let expiresAfter: OpenAIVectorStoreExpiresAfter?

    /// A list of File IDs that the vector store should use. Useful for tools like `file_search` that can access files.
    public let fileIds: [String]?

    /// Set of 16 key-value pairs that can be attached to an object.
    /// This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.
    /// Keys are strings with a maximum length of 64 characters.
    /// Values are strings with a maximum length of 512 characters.
    public let metadata: [String: String]?

    /// The name of the vector store.
    public let name: String?

    private enum CodingKeys: String, CodingKey {
        case chunkingStrategy = "chunking_strategy"
        case expiresAfter = "expires_after"
        case fileIds = "file_ids"
        case metadata
        case name
    }

    // This memberwise initializer is autogenerated.
    // To regenerate, use `cmd-shift-a` > Generate Memberwise Initializer
    // To format, place the cursor in the initializer's parameter list and use `ctrl-m`
    public init(
        chunkingStrategy: OpenAICreateVectorStoreRequestBody.ChunkingStrategy? = nil,
        expiresAfter: OpenAIVectorStoreExpiresAfter? = nil,
        fileIds: [String]? = nil,
        metadata: [String : String]? = nil,
        name: String? = nil
    ) {
        self.chunkingStrategy = chunkingStrategy
        self.expiresAfter = expiresAfter
        self.fileIds = fileIds
        self.metadata = metadata
        self.name = name
    }
}

extension OpenAICreateVectorStoreRequestBody {
    /// Strategy for chunking files when adding them to a vector store.
    public enum ChunkingStrategy: Encodable {
        /// The default strategy.
        /// This strategy currently uses a `max_chunk_size_tokens` of 800 and `chunk_overlap_tokens` of 400.
        case auto

        /// Customize your own chunking strategy by setting chunk size and chunk overlap
        ///
        /// - chunkOverlapTokens: The number of tokens that overlap between chunks. The default value is 400.
        ///                   Note that the overlap must not exceed half of `max_chunk_size_tokens`
        ///
        /// - maxChunkSizeTokens: The maximum number of tokens in each chunk.
        ///                    The default value is 800.
        ///                    The minimum value is 100 and the maximum value is 4096.
        case `static`(chunkOverlapTokens: Int, maxChunkSizeTokens: Int)

        private enum CodingKeys: String, CodingKey {
            case type
            case `static`
        }

        private enum NestedKeys: String, CodingKey {
            case chunkOverlapTokens = "chunk_overlap_tokens"
            case maxChunkSizeTokens = "max_chunk_size_tokens"
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .auto:
                try container.encode("auto", forKey: .type)
            case .static(let chunkOverlapTokens, let maxChunkSizeTokens):
                try container.encode("static", forKey: .type)
                var nested = container.nestedContainer(keyedBy: NestedKeys.self, forKey: .static)
                try nested.encode(chunkOverlapTokens, forKey: .chunkOverlapTokens)
                try nested.encode(maxChunkSizeTokens, forKey: .maxChunkSizeTokens)
            }
        }
    }
}
