//
//  OpenAIResponseInput.swift
//  AIProxy
//
//  Created by Lou Zell on 8/12/25.
//

import Foundation

extension OpenAIResponse {
    nonisolated public enum Input: Codable, Sendable {

        /// A text input to the model, equivalent to a text item with the user role.
        case text(String)

        /// A list of one or many input items to the model, containing different content types.
        case items([InputItem])

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .text(let txt):
                try container.encode(txt)
            case .items(let items):
                try container.encode(items)
            }
        }

        public init(from decoder: any Decoder) throws {
             let container = try decoder.singleValueContainer()

             if let str = try? container.decode(String.self) {
                 self = .text(str)
                 return
             }

            if let items = try? container.decode([OpenAIResponse.Input.InputItem].self) {
                 self = .items(items)
                 return
             }

             throw DecodingError.typeMismatch(
                 Input.self,
                 DecodingError.Context(
                     codingPath: decoder.codingPath,
                     debugDescription: "Expected String or array of ItemOrMessage"
                 )
             )
         }
    }
}

extension OpenAIResponse.Input {
    nonisolated public enum InputItem: Codable, Sendable {

        /// A message input to the model with a role indicating instruction following hierarchy.
        /// Instructions given with the developer or system role take precedence over instructions given with the user role.
        /// Messages with the assistant role are presumed to have been generated by the model in previous interactions.
        ///
        /// - Parameters:
        ///   - role: The role of the message input. One of user, assistant, system, or developer.
        ///
        ///   - Content: Text, image, or audio input to the model, used to generate a response.
        ///              Can also contain previous assistant responses.
        case message(role: Role, content: Content)
        
        case functionCall(OpenAIResponse.FunctionCall)
        
        case functionCallOutput(callID: String, output: String)
        
        case reasoning(id: String)

        private struct _Message: Codable, Sendable {
            let role: Role
            let content: Content

            private enum CodingKeys: CodingKey {
                case content
                case role
                case type
            }

            init(role: Role, content: Content) {
                self.role = role
                self.content = content
            }

            func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode("message", forKey: .type)
                try container.encode(self.role.rawValue, forKey: .role)
                try container.encode(self.content, forKey: .content)
            }

            init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let type = try container.decode(String.self, forKey: .type)
                if type == "message" {
                    self.role = try container.decode(Role.self, forKey: .role)
                    self.content = try container.decode(Content.self, forKey: .content)
                } else {
                    throw DecodingError.typeMismatch(
                        _Message.self,
                        DecodingError.Context(
                            codingPath: decoder.codingPath,
                            debugDescription: "Content of type \(type) could not be decoded as _Message"
                        )
                    )
                }
            }
        }
        
        private struct _FunctionCallOutput: Codable, Sendable {
            let callID: String
            let output: String

            private enum CodingKeys: String, CodingKey {
                case callID = "call_id"
                case output
                case type
            }

            init(callID: String, output: String) {
                self.callID = callID
                self.output = output
            }

            func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode("function_call_output", forKey: .type)
                try container.encode(callID, forKey: .callID)
                try container.encode(output, forKey: .output)
            }

            init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let type = try container.decode(String.self, forKey: .type)
                if type == "function_call_output" {
                    self.callID = try container.decode(String.self, forKey: .callID)
                    self.output = try container.decode(String.self, forKey: .output)
                } else {
                    throw DecodingError.typeMismatch(
                        _Message.self,
                        DecodingError.Context(
                            codingPath: decoder.codingPath,
                            debugDescription: "Content of type \(type) could not be decoded as _Message"
                        )
                    )
                }
            }
        }
        
        public struct _Reasoning: Codable, Sendable {
            
            let id: String
            
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .message(role: let role, content: let content):
                try container.encode(_Message(role: role, content: content))
            case .functionCall(let call):
                try container.encode(call)
            case .functionCallOutput(callID: let callID, output: let output):
                try container.encode(_FunctionCallOutput(callID: callID, output: output))
            case .reasoning(let id):
                try container.encode(_Reasoning(id: id))
            }
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let message = try? container.decode(_Message.self) {
                self = .message(role: message.role, content: message.content)
            } else if let functionCall = try? container.decode(OpenAIResponse.FunctionCall.self) {
                self = .functionCall(OpenAIResponse.FunctionCall(
                    id: functionCall.id,
                    callId: functionCall.callId,
                    name: functionCall.name,
                    arguments: functionCall.arguments,
                    status: functionCall.status
                ))
            } else if let functionCallOutput = try? container.decode(_FunctionCallOutput.self) {
                self = .functionCallOutput(callID: functionCallOutput.callID, output: functionCallOutput.output)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Unknown InputItem"
                )
            }
        }
    }
}

extension OpenAIResponse.Input.InputItem {
    nonisolated public enum Role: String, Codable, Sendable {
        case user
        case assistant
        case system
        case developer
    }

    nonisolated public enum Content: Codable, Sendable {
        case text(String)
        case list([ItemContent])

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .text(let txt):
                try container.encode(txt)
            case .list(let itemContent):
                try container.encode(itemContent)
            }
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.singleValueContainer()

            if let text = try? container.decode(String.self) {
                self = .text(text)
                return
            }

            if let list = try? container.decode([ItemContent].self) {
                self = .list(list)
                return
            }

            throw DecodingError.typeMismatch(
                Content.self,
                DecodingError.Context(
                    codingPath: decoder.codingPath,
                    debugDescription: "Content could not be decoded as either String or [ItemContent]"
                )
            )
        }
    }
}

extension OpenAIResponse.Input.InputItem.Content {
    nonisolated public enum ItemContent: Codable, Sendable {
        case file(fileID: String)
        case imageURL(URL)
        case text(String)

        private enum CodingKeys: String, CodingKey {
            case fileID = "file_id"
            case imageURL = "image_url"
            case type
            case text
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .file(let fileID):
                try container.encode(fileID, forKey: .fileID)
                try container.encode("input_file", forKey: .type)
            case .imageURL(let imageURL):
                try container.encode(imageURL, forKey: .imageURL)
                try container.encode("input_image", forKey: .type)
            case .text(let txt):
                try container.encode(txt, forKey: .text)
                try container.encode("input_text", forKey: .type)
            }
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)

            switch type {
            case "input_file":
                let fileID = try container.decode(String.self, forKey: .fileID)
                self = .file(fileID: fileID)

            case "input_image":
                let imageURL = try container.decode(URL.self, forKey: .imageURL)
                self = .imageURL(imageURL)

            case "input_text":
                let txt = try container.decode(String.self, forKey: .text)
                self = .text(txt)

            default:
                throw DecodingError.dataCorruptedError(
                    forKey: .type,
                    in: container,
                    debugDescription: "Unknown ItemContent type: \(type)"
                )
            }
        }
    }
}
