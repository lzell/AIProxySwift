//
//  GrogChatCompletionResponseBody.swift
//
//
//  Created by Lou Zell on 9/30/24.
//

import Foundation

/// Docstrings from: https://platform.openai.com/docs/api-reference/chat/object
public struct MistralChatCompletionResponseBody: Decodable {
    /// A list of chat completion choices.
    /// Can be more than one if `n` on `MistralChatCompletionRequestBody` is greater than 1.
    public let choices: [Choice]

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public let created: Int

    /// The model used for the chat completion.
    public let model: String

    /// Usage statistics for the completion request.
    public let usage: MistralChatUsage?
    
    public init(choices: [Choice], created: Int, model: String, usage: MistralChatUsage?) {
        self.choices = choices
        self.created = created
        self.model = model
        self.usage = usage
    }
}

// MARK: - ResponseBody.Choice
extension MistralChatCompletionResponseBody {
    public struct Choice: Decodable {
        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a
        /// natural stop point or a provided stop sequence, `length` if the maximum number of
        /// tokens specified in the request was reached, `content_filter` if content was omitted
        /// due to a flag from our content filters, `tool_calls` if the model called a tool, or
        /// `function_call` (deprecated) if the model called a function.
        public let finishReason: String?

        /// A chat completion message generated by the model.
        public let message: Message
        
        public init(finishReason: String?, message: Message) {
            self.finishReason = finishReason
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case finishReason = "finish_reason"
            case message
        }
    }
}

// MARK: - ResponseBody.Choice.Message
extension MistralChatCompletionResponseBody.Choice {
    public struct Message: Decodable {
        /// The contents of the message.
        public let content: String

        /// The role of the author of this message.
        public let role: String

        /// The tool calls generated by the model, such as function calls.
        // public let toolCalls: [ToolCall]?
        
        public init(content: String, role: String) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case role
            // case toolCalls = "tool_calls"
        }
    }
}
