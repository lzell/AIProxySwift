//
//  PerplexityChatCompletionResponseBody.swift
//
//
//  Created by Lou Zell on 11/6/24.
//

import Foundation

/// Docstrings from: https://docs.perplexity.ai/api-reference/chat-completions
nonisolated public struct PerplexityChatCompletionResponseBody: Decodable, Sendable {
    /// The list of completion choices the model generated for the input prompt.
    public let choices: [Choice]

    /// Citations for the generated answer.
    public let citations: [String]?

    /// The Unix timestamp (in seconds) of when the completion was created.
    public let created: Int?

    /// An ID generated uniquely for each response.
    public let id: String?

    /// The model used to generate the response.
    public let model: String?

    /// The object type, which always equals "chat.completion"
    public let object: String?

    /// Usage statistics for the completion request.
    public let usage: Usage?
    
    public init(choices: [Choice], citations: [String]?, created: Int?, id: String?, model: String?, object: String?, usage: Usage?) {
        self.choices = choices
        self.citations = citations
        self.created = created
        self.id = id
        self.model = model
        self.object = object
        self.usage = usage
    }
}

// MARK: - ResponseBody.Choice
extension PerplexityChatCompletionResponseBody {
    nonisolated public struct Choice: Decodable, Sendable {

        /// The incrementally streamed next tokens. Only meaningful when stream = true
        public let delta: Delta?

        /// The reason the model stopped generating tokens. Possible values include stop if the
        /// model hit a natural stopping point, or length if the maximum number of tokens
        /// specified in the request was reached.
        public let finishReason: FinishReason?

        public let index: Int?

        /// The message generated by the model.
        public let message: Message?

        private enum CodingKeys: String, CodingKey {
            case delta
            case finishReason = "finish_reason"
            case index
            case message
        }
        
        public init(delta: Delta?, finishReason: FinishReason?, index: Int?, message: Message?) {
            self.delta = delta
            self.finishReason = finishReason
            self.index = index
            self.message = message
        }
    }
}

// MARK: - PerplexityChatCompletionResponseBody.Choice.Delta
extension PerplexityChatCompletionResponseBody.Choice {
    nonisolated public struct Delta: Decodable, Sendable {
        public let content: String
        public let role: PerplexityRole
        
        public init(content: String, role: PerplexityRole) {
            self.content = content
            self.role = role
        }
    }
}


// MARK: - ResponseBody.Choice.FinishReason
extension PerplexityChatCompletionResponseBody.Choice {
    nonisolated public enum FinishReason: String, Decodable, Sendable {
        case stop
        case length
    }
}

// MARK: - ResponseBody.Choice.Message
extension PerplexityChatCompletionResponseBody.Choice {
    /// After the (optional) system message, user and assistant roles should alternate with
    /// user then assistant, ending in user.
    nonisolated public struct Message: Decodable, Sendable {
        public let content: String
        public let role: PerplexityRole
        
        public init(content: String, role: PerplexityRole) {
            self.content = content
            self.role = role
        }
    }
}

// MARK: - ResponseBody.Usage
extension PerplexityChatCompletionResponseBody {
    nonisolated public struct Usage: Decodable, Sendable {
        /// The number of tokens provided in the request prompt.
        public let promptTokens: Int?

        /// The number of tokens generated in the response output.
        public let completionTokens: Int?

        /// The total number of tokens used in the chat completion (prompt + completion).
        public let totalTokens: Int?

        private enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
        }
        
        public init(promptTokens: Int?, completionTokens: Int?, totalTokens: Int?) {
            self.promptTokens = promptTokens
            self.completionTokens = completionTokens
            self.totalTokens = totalTokens
        }
    }
}
