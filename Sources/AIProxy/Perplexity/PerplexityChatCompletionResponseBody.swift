//
//  PerplexityChatCompletionResponseBody.swift
//
//
//  Created by Lou Zell on 11/6/24.
//

import Foundation

/// Docstrings from: https://docs.perplexity.ai/api-reference/chat-completions
public struct PerplexityChatCompletionResponseBody: Decodable {
    /// The list of completion choices the model generated for the input prompt.
    public let choices: [Choice]

    /// The Unix timestamp (in seconds) of when the completion was created.
    public let created: Int?

    /// An ID generated uniquely for each response.
    public let id: String?

    /// The model used to generate the response.
    public let model: String?

    /// The object type, which always equals "chat.completion"
    public let object: String?

    /// Usage statistics for the completion request.
    public let usage: Usage?
}

// MARK: - ResponseBody.Choice
extension PerplexityChatCompletionResponseBody {
    public struct Choice: Decodable {
        /// The reason the model stopped generating tokens. Possible values include stop if the
        /// model hit a natural stopping point, or length if the maximum number of tokens
        /// specified in the request was reached.
        public let finishReason: FinishReason?

        public let index: Int?

        /// The message generated by the model.
        public let message: Message

        private enum CodingKeys: String, CodingKey {
            case finishReason = "finish_reason"
            case index
            case message
        }
    }
}

// MARK: - ResponseBody.Choice.FinishReason
extension PerplexityChatCompletionResponseBody.Choice {
    public enum FinishReason: String, Decodable {
        case stop
        case length
    }
}

// MARK: - ResponseBody.Choice.Message
extension PerplexityChatCompletionResponseBody.Choice {
    /// After the (optional) system message, user and assistant roles should alternate with
    /// user then assistant, ending in user.
    public struct Message: Decodable {
        public let content: String
        public let role: Role
    }
}

// MARK: - ResponesBody.Choice.Message.Role
extension PerplexityChatCompletionResponseBody.Choice.Message {
    public enum Role: String, Decodable {
        case system
        case user
        case assistant
    }
}


//
// The incrementally streamed next tokens. Only meaningful when stream = true.
// choices.delta.content
// string
// required
//
// The contents of the message in this turn of conversation.
// choices.delta.role
// enum<string>
// required
//
// The role of the speaker in this turn of conversation. After the (optional) system message, user and assistant roles should alternate with user then assistant, ending in user.
// Available options: system,
// user,
// assistant
// usage
// object
//

// MARK: - ResponseBody.Usage
extension PerplexityChatCompletionResponseBody {
    public struct Usage: Decodable {
        /// The number of tokens provided in the request prompt.
        public let promptTokens: Int?

        /// The number of tokens generated in the response output.
        public let completionTokens: Int?

        /// The total number of tokens used in the chat completion (prompt + completion).
        public let totalTokens: Int?

        private enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
        }
    }
}
