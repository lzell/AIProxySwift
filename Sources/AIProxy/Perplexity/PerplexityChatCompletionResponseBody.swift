//
//  PerplexityChatCompletionResponseBody.swift
//
//
//  Created by Lou Zell on 11/6/24.
//

import Foundation

/// Docstrings from: https://docs.perplexity.ai/api-reference/chat-completions
public struct PerplexityChatCompletionResponseBody: Decodable {
    /// The list of completion choices the model generated for the input prompt.
    public let choices: [Choice]

    /// Citations for the generated answer.
    public let citations: [String]?

    /// The Unix timestamp (in seconds) of when the completion was created.
    public let created: Int?

    /// An ID generated uniquely for each response.
    public let id: String?

    /// The model used to generate the response.
    public let model: String?

    /// The object type, which always equals "chat.completion"
    public let object: String?

    /// Usage statistics for the completion request.
    public let usage: Usage?
}

// MARK: - ResponseBody.Choice
extension PerplexityChatCompletionResponseBody {
    public struct Choice: Decodable {

        /// The incrementally streamed next tokens. Only meaningful when stream = true
        public let delta: Delta?

        /// The reason the model stopped generating tokens. Possible values include stop if the
        /// model hit a natural stopping point, or length if the maximum number of tokens
        /// specified in the request was reached.
        public let finishReason: FinishReason?

        public let index: Int?

        /// The message generated by the model.
        public let message: Message?

        private enum CodingKeys: String, CodingKey {
            case delta
            case finishReason = "finish_reason"
            case index
            case message
        }
    }
}

// MARK: - PerplexityChatCompletionResponseBody.Choice.Delta
extension PerplexityChatCompletionResponseBody.Choice {
    public struct Delta: Decodable {
        public let content: String
        public let role: PerplexityRole
    }
}


// MARK: - ResponseBody.Choice.FinishReason
extension PerplexityChatCompletionResponseBody.Choice {
    public enum FinishReason: String, Decodable {
        case stop
        case length
    }
}

// MARK: - ResponseBody.Choice.Message
extension PerplexityChatCompletionResponseBody.Choice {
    /// After the (optional) system message, user and assistant roles should alternate with
    /// user then assistant, ending in user.
    public struct Message: Decodable {
        public let content: String
        public let role: PerplexityRole
    }
}

// MARK: - ResponseBody.Usage
extension PerplexityChatCompletionResponseBody {
    public struct Usage: Decodable {
        /// The number of tokens provided in the request prompt.
        public let promptTokens: Int?

        /// The number of tokens generated in the response output.
        public let completionTokens: Int?

        /// The total number of tokens used in the chat completion (prompt + completion).
        public let totalTokens: Int?

        private enum CodingKeys: String, CodingKey {
            case promptTokens = "prompt_tokens"
            case completionTokens = "completion_tokens"
            case totalTokens = "total_tokens"
        }
    }
}
