//
//  GrogChatCompletionResponseBody.swift
//
//
//  Created by Lou Zell on 9/30/24.
//

import Foundation

/// Docstrings from: https://platform.openai.com/docs/api-reference/chat/object
nonisolated public struct GroqChatCompletionResponseBody: Decodable, Sendable {
    /// A list of chat completion choices.
    /// Can be more than one if `n` on `GroqChatCompletionRequestBody` is greater than 1.
    public let choices: [Choice]

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public let created: Int

    /// The model used for the chat completion.
    public let model: String

    /// Usage statistics for the completion request.
    public let usage: Usage?

    public init(choices: [Choice], created: Int, model: String, usage: Usage?) {
        self.choices = choices
        self.created = created
        self.model = model
        self.usage = usage
    }
}

// MARK: - ResponseBody.Choice
extension GroqChatCompletionResponseBody {
    nonisolated public struct Choice: Decodable, Sendable {
        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a
        /// natural stop point or a provided stop sequence, `length` if the maximum number of
        /// tokens specified in the request was reached, `content_filter` if content was omitted
        /// due to a flag from our content filters, `tool_calls` if the model called a tool, or
        /// `function_call` (deprecated) if the model called a function.
        public let finishReason: String?

        /// A chat completion message generated by the model.
        public let message: Message

        public init(finishReason: String?, message: Message) {
            self.finishReason = finishReason
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case finishReason = "finish_reason"
            case message
        }
    }
}

// MARK: - ResponseBody.Choice.Message
extension GroqChatCompletionResponseBody.Choice {
    nonisolated public struct Message: Decodable, Sendable {
        /// The contents of the message.
        public let content: String?

        /// The role of the author of this message.
        public let role: String

        /// The tool calls generated by the model, such as function calls.
        // public let toolCalls: [ToolCall]?

        public init(content: String?, role: String) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case role
            // case toolCalls = "tool_calls"
        }
    }
}

// MARK: - ResponseBody.Usage
extension GroqChatCompletionResponseBody {
    nonisolated public struct Usage: Decodable, Sendable {
        public let completionTime: Double?
        public let completionTokens: Int?
        public let promptTime: Double?
        public let promptTokens: Int?
        public let totalTime: Double?
        public let totalTokens: Int?

        public init(completionTime: Double?, completionTokens: Int?, promptTime: Double?, promptTokens: Int?, totalTime: Double?, totalTokens: Int?) {
            self.completionTime = completionTime
            self.completionTokens = completionTokens
            self.promptTime = promptTime
            self.promptTokens = promptTokens
            self.totalTime = totalTime
            self.totalTokens = totalTokens
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completion_time"
            case completionTokens = "completion_tokens"
            case promptTime = "prompt_time"
            case promptTokens = "prompt_tokens"
            case totalTime = "total_time"
            case totalTokens = "total_tokens"
        }
    }
}
