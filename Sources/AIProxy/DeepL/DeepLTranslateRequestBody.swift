//
//  DeepLTranslateRequestBody.swift
//
//
//  Created by Lou Zell on 8/3/24.
//

import Foundation

/// All docstrings on this model are from:
/// https://developers.deepl.com/docs/api-reference/translate/openapi-spec-for-text-translation
nonisolated public struct DeepLTranslateRequestBody: Encodable, Sendable {
    // MARK: Required
    /// The language into which the text should be translated.
    /// Example: "DE"
    /// Possible values:
    ///   AR, BG, CS, DA, DE, EL, EN-GB, EN-US, ES, ET, FI, FR, HU, ID, IT, JA, KO, LT, LV, NB,
    ///   NL, PL, PT-BR, PT-PT, RO, RU, SK, SL, SV, TR, UK, ZH, ZH-HANS, ZH-HANT
    public let targetLang: String

    /// Text to be translated. Only UTF-8-encoded plain text is supported. The parameter may be
    /// specified up to 50 times in a single request. Translations are returned in the same
    /// order as they are requested.
    public let text: [String]

    // MARK: Optional
    /// Additional context that can influence a translation but is not translated itself.
    /// Characters included in the context parameter will not be counted toward billing.
    public let context: String?

    /// Sets whether the translated text should lean towards formal or informal language. This
    /// feature is only available for certain target languages. Setting this parameter with a
    /// target language that does not support formality will fail, unless one of the
    /// `prefer_...` options are used
    public let formality: DeepLFormality?

    /// Specify the glossary to use for the translation. Important: This requires the
    /// `source_lang` parameter to be set. The language pair of the glossary has to match the
    /// language pair of the request.
    /// Example: "def3a26b-3e84-45b3-84ae-0c0aaf3525f7"
    public let glossaryID: String?

    /// List of HTML or XML tags that indicate text not to be translated.
    public let ignoreTags: [String]?

    /// List of HTML or XML tags which never split sentences.
    public let nonSplittingTags: [String]?

    /// Disable the automatic detection of XML structure by setting this parameter to false and
    /// selecting the tags that should be considered structure tags. This will split sentences
    /// using the `splittingTags` parameter.
    public let outlineDetection: Bool?

    /// Sets whether the translation engine should respect the original formatting, even if it
    /// would usually correct some aspects.
    public let preserveFormatting: Bool?

    /// Language of the text to be translated. If this parameter is omitted, the API will
    /// attempt to detect the language of the text and translate it.
    ///
    /// Example: "EN"
    /// Possible values:
    ///     BG, CS, DA, DE, EL, EN, ES, ET, FI, FR, HU, ID, IT, JA, KO, LT, LV, NB, NL, PL, PT, RO,
    ///     RU, SK, SL, SV, TR, UK, ZH
    public let sourceLang: String?

    /// Sets whether the translation engine should first split the input into sentences.
    public let splitSentences: DeepLSplitSentencesOption?

    /// Comma-separated list of HTML or XML tags which always cause splits.
    public let splittingTags: [String]?

    /// Sets which kind of tags should be handled.
    /// Options currently available: `.xml` and `.xhtml`
    public let tagHandling: DeepLTagHandling?

    private enum CodingKeys: String, CodingKey {
        // Required
        case targetLang = "target_lang"
        case text = "text"

        // Optional
        case context = "context"
        case formality = "formality"
        case glossaryID = "glossary_id"
        case ignoreTags = "ignore_tags"
        case nonSplittingTags = "non_splitting_tags"
        case outlineDetection = "outline_detection"
        case preserveFormatting = "preserve_formatting"
        case sourceLang = "source_lang"
        case splitSentences = "split_sentences"
        case splittingTags = "splitting_tags"
        case tagHandling = "tag_handling"
    }

    // This memberwise initializer is autogenerated.
    // To regenerate, use `cmd-shift-a` > Generate Memberwise Initializer
    // To format, place the cursor in the initializer's parameter list and use `ctrl-m`
    public init(
        targetLang: String,
        text: [String],
        context: String? = nil,
        formality: DeepLFormality? = nil,
        glossaryID: String? = nil,
        ignoreTags: [String]? = nil,
        nonSplittingTags: [String]? = nil,
        outlineDetection: Bool? = nil,
        preserveFormatting: Bool? = nil,
        sourceLang: String? = nil,
        splitSentences: DeepLSplitSentencesOption? = nil,
        splittingTags: [String]? = nil,
        tagHandling: DeepLTagHandling? = nil
    ) {
        self.targetLang = targetLang
        self.text = text
        self.context = context
        self.formality = formality
        self.glossaryID = glossaryID
        self.ignoreTags = ignoreTags
        self.nonSplittingTags = nonSplittingTags
        self.outlineDetection = outlineDetection
        self.preserveFormatting = preserveFormatting
        self.sourceLang = sourceLang
        self.splitSentences = splitSentences
        self.splittingTags = splittingTags
        self.tagHandling = tagHandling
    }
}

nonisolated public enum DeepLFormality: String, Encodable, Sendable {
    case `default` = "default"

    /// for a more formal language
    case more = "more"

    /// a more informal language
    case less = "less"

    /// a more formal language if available, otherwise fallback to default formality
    case preferMore = "prefer_more"

    /// a more informal language if available, otherwise fallback to default formality
    case preferLess = "prefer_less"
}

/// Sets whether the translation engine should first split the input into sentences.
nonisolated public enum DeepLSplitSentencesOption: String, Encodable, Sendable {
    case none = "0"
    case punctuation = "nonewlines"
    case punctuationAndNewlines = "1"
}

nonisolated public enum DeepLTagHandling: String, Encodable, Sendable {
    case xml
    case xhtml
}
