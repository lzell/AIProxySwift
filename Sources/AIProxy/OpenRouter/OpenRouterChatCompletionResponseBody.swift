//
//  OpenRouterChatCompletionResponseBody.swift
//  AIProxy
//
//  Created by Lou Zell on 12/30/24.
//

import Foundation

nonisolated public struct OpenRouterChatCompletionResponseBody: Decodable, Sendable {
    /// A list of chat completion choices.
    /// Can be more than one if `n` on `OpenRouterChatCompletionRequestBody` is greater than 1.
    public let choices: [Choice]

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public let created: Int?

    public let id: String?

    /// The model used for the chat completion.
    public let model: String?

    /// The provider used to fulfill the chat completion.
    public let provider: String?

    /// Usage statistics for the completion request.
    public let usage: Usage?

    private enum CodingKeys: String, CodingKey {
        case choices
        case created
        case id
        case model
        case provider
        case usage
    }

    public init(choices: [Choice], created: Int?, id: String?, model: String?, provider: String?, usage: Usage?) {
        self.choices = choices
        self.created = created
        self.id = id
        self.model = model
        self.provider = provider
        self.usage = usage
    }
}

// MARK: - ResponseBody.Usage
extension OpenRouterChatCompletionResponseBody {
    nonisolated public struct Usage: Decodable, Sendable {
        /// Number of tokens in the generated completion.
        public let completionTokens: Int?

        /// Number of tokens in the prompt.
        public let promptTokens: Int?

        /// Total number of tokens used in the request (prompt + completion).
        public let totalTokens: Int?

        private enum CodingKeys: String, CodingKey {
            case completionTokens = "completion_tokens"
            case promptTokens = "prompt_tokens"
            case totalTokens = "total_tokens"
        }

        public init(completionTokens: Int?, promptTokens: Int?, totalTokens: Int?) {
            self.completionTokens = completionTokens
            self.promptTokens = promptTokens
            self.totalTokens = totalTokens
        }
    }
}

// MARK: - ResponseBody.Choice
extension OpenRouterChatCompletionResponseBody {
    nonisolated public struct Choice: Decodable, Sendable {
        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a
        /// natural stop point or a provided stop sequence, `length` if the maximum number of
        /// tokens specified in the request was reached, `content_filter` if content was omitted
        /// due to a flag from our content filters, `tool_calls` if the model called a tool, or
        /// `function_call` (deprecated) if the model called a function.
        public let finishReason: String?

        /// A chat completion message generated by the model.
        public let message: Message

        public let nativeFinishReason: String?

        private enum CodingKeys: String, CodingKey {
            case finishReason = "finish_reason"
            case message
            case nativeFinishReason = "native_finish_reason"
        }

        public init(finishReason: String?, message: Message, nativeFinishReason: String?) {
            self.finishReason = finishReason
            self.message = message
            self.nativeFinishReason = nativeFinishReason
        }
    }
}

extension OpenRouterChatCompletionResponseBody.Choice {
    nonisolated public struct Message: Decodable, Sendable {
        /// Web search annotations when using online models (e.g., "model:online")
        public let annotations: [Annotation]?

        /// The contents of the message.
        public let content: String?

        /// Reasoning models such as R1 will populate this field with the reasoning used to arrive at `content`
        public let reasoning: String?

        /// The role of the author of this message.
        public let role: String?

        /// The tool calls generated by the model, such as function calls.
        public let toolCalls: [ToolCall]?

        private enum CodingKeys: String, CodingKey {
            case annotations
            case content
            case reasoning
            case role
            case toolCalls = "tool_calls"
        }

        public init(
            annotations: [Annotation]? = nil,
            content: String? = nil,
            reasoning: String? = nil,
            role: String? = nil,
            toolCalls: [ToolCall]? = nil
        ) {
            self.annotations = annotations
            self.content = content
            self.reasoning = reasoning
            self.role = role
            self.toolCalls = toolCalls
        }
    }
}

// MARK: - ResponseBody.Choice.Message.Annotation
extension OpenRouterChatCompletionResponseBody.Choice.Message {
    /// https://platform.openai.com/docs/api-reference/chat/object#chat/object-choices-message-annotations
    nonisolated public struct Annotation: Decodable, Sendable {
        /// URL citation information when type is "url_citation"
        public let urlCitation: URLCitation?

        private enum CodingKeys: String, CodingKey {
            case urlCitation = "url_citation"
        }

        public init(urlCitation: URLCitation?) {
            self.urlCitation = urlCitation
        }
    }
}

// MARK: - ResponseBody.Choice.Message.URLCitation
extension OpenRouterChatCompletionResponseBody.Choice.Message {
    nonisolated public struct URLCitation: Decodable, Sendable {
        /// Content snippet from the web page
        public let content: String?

        /// End index in the response where this citation applies
        public let endIndex: Int?

        /// Start index in the response where this citation applies
        public let startIndex: Int?

        /// The title of the web page
        public let title: String?

        /// The URL of the web source
        public let url: String?

        private enum CodingKeys: String, CodingKey {
            case content
            case endIndex = "end_index"
            case startIndex = "start_index"
            case title
            case url
        }

        public init(
            content: String? = nil,
            endIndex: Int? = nil,
            startIndex: Int? = nil,
            title: String? = nil,
            url: String? = nil
        ) {
            self.content = content
            self.endIndex = endIndex
            self.startIndex = startIndex
            self.title = title
            self.url = url
        }
    }
}

// MARK: - ResponseBody.Choice.Message.ToolCall
extension OpenRouterChatCompletionResponseBody.Choice.Message {
    nonisolated public struct ToolCall: Decodable, Sendable {
        /// The function that the model instructs us to call
        public let function: Function?

        public let id: String?

        public let index: Int?

        /// The type of the tool. Currently, only `function` is supported.
        public let type: String?

        public init(function: Function?, id: String?, index: Int?, type: String?) {
            self.function = function
            self.id = id
            self.index = index
            self.type = type
        }
    }
}

// MARK: - ResponseBody.Choice.Message.ToolCall.Function
extension OpenRouterChatCompletionResponseBody.Choice.Message.ToolCall {
    nonisolated public struct Function: Decodable, Sendable {
        /// The name of the function to call.
        public let name: String

        /// The arguments to call the function with.
        public let arguments: [String: any Sendable]?

        /// The raw arguments string, unmapped to a `[String: Any]`. The unmapped string is useful for
        /// continuing the converstation with the model. The model expects you to feed the raw argument string
        /// back to the model on susbsequent requests.
        public let argumentsRaw: String?

        private enum CodingKeys: CodingKey {
            case name
            case arguments
        }
        public init(name: String, arguments: [String: AIProxyJSONValue]?, argumentsRaw: String?) {
            self.name = name
            self.arguments = arguments
            self.argumentsRaw = argumentsRaw
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try container.decode(String.self, forKey: .name)
            if let argumentsRaw = try? container.decode(String.self, forKey: .arguments) {
                self.argumentsRaw = argumentsRaw
                self.arguments = (try [String: AIProxyJSONValue].deserialize(from: argumentsRaw)).untypedDictionary
            } else {
                self.argumentsRaw = nil
                self.arguments = nil
            }
        }
    }
}
